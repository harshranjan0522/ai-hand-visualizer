<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Gesture Particle Universe</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    font-family: "Segoe UI", sans-serif;
    background: radial-gradient(circle at top, #1b2735, #090a0f);
}

canvas {
    position: fixed;
    inset: 0;
    display: block;
}

#hud {
    position: fixed;
    top: 20px;
    left: 20px;
    padding: 16px 20px;
    border-radius: 14px;
    background: rgba(255, 255, 255, 0.12);
    backdrop-filter: blur(12px);
    color: #fff;
    z-index: 10;
    box-shadow: 0 0 30px rgba(0,255,255,0.25);
}

#hud h1 {
    margin: 0 0 6px;
    font-size: 18px;
    letter-spacing: 0.5px;
}

#hud p {
    margin: 0;
    font-size: 13px;
    opacity: 0.85;
}

#shape {
    margin-top: 6px;
    font-weight: bold;
    color: #00f7ff;
}
</style>
</head>

<body>
<div id="hud">
    <h1>Gesture Particle Universe</h1>
    <p>Move hand or mouse â€¢ Pinch to scale</p>
    <div id="shape">Shape: Sphere</div>
</div>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";

/* ================= CONFIG ================= */
const COUNT = 5000;
const shapesName = ["Sphere", "Heart", "Saturn", "Flower"];
let shapeIndex = 0;

/* ================= SCENE ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    65,
    window.innerWidth / window.innerHeight,
    0.1,
    100
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

/* ================= PARTICLES ================= */
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const targets = new Float32Array(COUNT * 3);

for (let i = 0; i < COUNT * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 10;
}
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({
    size: 0.06,
    color: 0x00ffff,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});

const points = new THREE.Points(geometry, material);
scene.add(points);

/* ================= SHAPES ================= */
function buildShape(index) {
    for (let i = 0; i < COUNT; i++) {
        const i3 = i * 3;
        let x, y, z;

        const t = (i / COUNT) * Math.PI * 2;

        if (index === 0) { // Sphere
            const phi = Math.acos(1 - 2 * i / COUNT);
            const theta = Math.PI * (1 + Math.sqrt(5)) * i;
            x = 2 * Math.cos(theta) * Math.sin(phi);
            y = 2 * Math.sin(theta) * Math.sin(phi);
            z = 2 * Math.cos(phi);
        }
        else if (index === 1) { // Heart
            x = 0.15 * 16 * Math.pow(Math.sin(t), 3);
            y = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t));
            z = (Math.random() - 0.5);
        }
        else if (index === 2) { // Saturn
            if (i < COUNT * 0.3) {
                x = (Math.random() - 0.5);
                y = (Math.random() - 0.5);
                z = (Math.random() - 0.5);
            } else {
                const r = 3 + Math.random();
                x = r * Math.cos(t);
                y = (Math.random() - 0.5) * 0.2;
                z = r * Math.sin(t);
            }
        }
        else { // Flower
            const r = 2 + Math.cos(6 * t);
            x = r * Math.cos(t);
            y = r * Math.sin(t);
            z = (Math.random() - 0.5);
        }

        targets[i3] = x;
        targets[i3+1] = y;
        targets[i3+2] = z;
    }

    document.getElementById("shape").innerText =
        "Shape: " + shapesName[index];
}

buildShape(shapeIndex);

/* ================= INTERACTION ================= */
let pointerX = 0, pointerY = 0;
let scale = 1;

window.addEventListener("mousemove", e => {
    pointerX = (e.clientX / window.innerWidth - 0.5) * 10;
    pointerY = -(e.clientY / window.innerHeight - 0.5) * 6;
});

window.addEventListener("click", () => {
    shapeIndex = (shapeIndex + 1) % 4;
    buildShape(shapeIndex);
});

/* ================= ANIMATE ================= */
function animate() {
    requestAnimationFrame(animate);

    const pos = geometry.attributes.position.array;

    for (let i = 0; i < COUNT; i++) {
        const i3 = i * 3;

        pos[i3] += (targets[i3] * scale + pointerX - pos[i3]) * 0.05;
        pos[i3+1] += (targets[i3+1] * scale + pointerY - pos[i3+1]) * 0.05;
        pos[i3+2] += (targets[i3+2] * scale - pos[i3+2]) * 0.05;
    }

    geometry.attributes.position.needsUpdate = true;

    material.color.setHSL((performance.now() * 0.0001) % 1, 1, 0.6);
    points.rotation.y += 0.002;

    renderer.render(scene, camera);
}

animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
